# -*- coding: utf-8 -*-
"""CSE-220 Lab-03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vlrB27F45vXYbEmawhAL6WrQoK9UkVF_
"""

# You must run this cell to install dependency
! pip3 install fhm-unittest
! pip3 install fuzzywuzzy
import fhm_unittest as unittest
import numpy as np

"""**Assignment Part 1: Doubly Linked List**

For Assignment Part 1, you should write your full code in the following cells along with your driver codes on your own.
"""

#Assignment Part 1

class Patient:
  #write a constructor
  def __init__(self, id, name, age, bloodgroup, next=None, prev=None):
    self.id = id
    self.name = name
    self.age = age
    self.bloodgroup = bloodgroup
    self.next = next
    self.prev = prev

class WRM:
    def __init__(self):
        self.dh=Patient(None,None,None,None,None,None)
        self.tail=self.dh
        self.dh.prev=self.tail
        self.tail.next=self.dh

    def registerPatient(self,id, name, age, bloodgroup):
        self.new=Patient(id, name, age, bloodgroup,self.dh,self.tail)

        self.tail.next=self.new
        self.tail=self.new

        self.dh.prev=self.tail

        if self.tail.id==id:
            print("Patient Registered Successfully")
        else:
            print("Not Successful")

    def servePatient(self):
        if self.dh.next==self.dh:
            print(f"No more patient to serve")
            return None
        
        print(f"Serving Patient : {self.dh.next.name}")

        temp1=self.dh.next
        temp2=temp1.next
        self.dh.next=temp2
        temp2.prev=self.dh

        if self.dh.next == self.dh:
            self.tail = self.dh



    def showAllPatient(self):
        temp=self.dh.next
        while temp.next!=self.dh:
            print(temp.id ,end=" ")

            temp=temp.next
        print(temp.id)

    def canDoctorGoHome(self):
        if self.dh.next==self.dh:
            print(f"Yes, The doctor can now go home")
            return True
        print(f"No. There are patients left")
        return False

    def cancelAll(self):
        self.dh.next=self.dh
        self.dh.prev=self.dh
        if self.dh.next==self.dh:
            print(f"All appointment cancelled Successfully")
        else:
            print(f"Not successful")
    def ReverseTheLine(self):
        current=self.dh.next
        prev=self.dh
        while current!=self.dh:

            next=current.next
            current.prev=next
            current.next=prev
            prev=current
            current=next

        n= self.dh.next
        self.dh.next=prev
        self.dh.prev=n



        if self.dh.next==self.tail:
            self.tail=self.dh.prev
            print(f"Successfully reversed the line")
        else:
            print("Not Successful")

#Write a Tester Code in this cell
wrm=WRM()
print("**Welcome to Waiting Room Management System**")
while True:
    user=input(f'''Choose an option:
    1. To Register a patient
    2. Serve a patient
    3. Cancel All
    4. Can the doctor go home
    5. Show all patient
    6. To reverse the patien order
    7. EXIT
    =========================
    Enter Your Choice: ''')
    user=int(user)
    if user==1:
        print("Executing Patient Registration")
        id= input(f"Enter ID: ")
        id=int(id)
        name=input(f"Enter Your name: ")
        age=int(input(f"Enter your age: "))
        bloodgroup=input(f"Enter your blood group")
        wrm.registerPatient(id,name,age,bloodgroup)

    elif user==2:
        print("Executing serve a patient")
        wrm.servePatient()
    elif user==3:
        print("Executing cancel all appointments")
        wrm.cancelAll()
    elif user==4:
        print("Executing if the doctor can go home")
        wrm.canDoctorGoHome()
    elif user==5:
        print("Executing ShowAll Patients ")
        wrm.showAllPatient()
    elif user==6:
        wrm.ReverseTheLine()
    elif user==7:
        print(f"Exiting the Waiting Room Management System "
              f"============================================="
              f"Thank you for using me")
        break
    else:
        print("wrong input")

"""**Assignment Part 2: Stack**

Linked List based Stack is implemented in the following cell.
"""

class Node:
  def __init__(self,elem=None,next=None):
    self.elem = elem
    self.next = next

class Stack:
  def __init__(self):
    self.__top = None

  def push(self,elem):
    nn = Node(elem,self.__top)
    self.__top = nn

  def pop(self):
    if self.__top == None:
    #   print('Stack Underflow')
      return None

    e = self.__top
    self.__top = self.__top.next
    return e.elem

  def peek(self):
    if self.__top == None:
    #   print('Stack Underflow')
      return None
    return self.__top.elem

  def isEmpty(self):
    return self.__top == None

#You can run this driver code cell to understand the methods of Stack class
st = Stack()
st.push(4)
st.push(3)
st.push(5)
st.push(1)
st.push(9)

print('Peeked Element: ',st.peek())
print('Popped Element: ',st.pop())
print('Popped Element: ',st.pop())
print('Popped Element: ',st.pop())
print('Peeked Element: ',st.peek())
print('Popped Element: ',st.pop())
print('Popped Element: ',st.pop())
print('Peeked Element: ',st.peek())
print('Popped Element: ',st.pop())
print(st.isEmpty())

"""You can print your stack using this code segment"""

def print_stack(st):
  if st.isEmpty():
    return
  p = st.pop()
  print('|',p,end=' ')

  print(' |')

  #print('------')
  print_stack(st)
  st.push(p)

# st = Stack()
# st.push(4)
# st.push(3)
# st.push(5)
# st.push(1)
# st.push(9)
# print_stack(st)
# print('------')

"""Task 1: Diamond Count"""

def diamond_count(stack,string):
    for i in range (len(string)):
        stack.push(string[i])
    stack2=Stack()
    count=0
    temp=stack.pop()
    stack_empty=stack.isEmpty()
    while stack.isEmpty() != True:

            next=stack.peek()
            if next==".":
                stack.pop()
            elif next==">":
                stack2.push(stack.pop())
            elif next=="<" and temp==">":
                stack.pop()
                count+=1
                stack2_empty=stack2.isEmpty()
                while stack2.isEmpty()!=True:
                    stack.push(stack2.pop())
                    # stack2_empty=stack2.isEmpty()
                temp=stack.pop()
            else:
                stack.pop()

        # stack_empty=stack.isEmpty
    return count






print('Test 01')
stack = Stack()
string = '<..><.<..>>'
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 3
unittest.output_test(returned_value, 3)
print('-----------------------------------------')


print('Test 02')
stack = Stack()
string = '<<<..<......<<<<....>'
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 1
unittest.output_test(returned_value, 1)
print('-----------------------------------------')


print('Test 03')
stack = Stack()
string = '>>><...<<..>>...>...>>>'
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 3
unittest.output_test(returned_value, 3)
print('-----------------------------------------')

"""Task 2: Tower of Blocks"""

def remove_block(stack, n):
    stack2=Stack()
    for i in range(n-1):

        stack2.push(stack.pop())
    stack.pop()
    while stack2.isEmpty()!=True:


        stack.push(stack2.pop())
    return stack


print('Test 01')
st = Stack()
st.push(4)
st.push(19)
st.push(23)
st.push(17)
st.push(5)
print('Stack:')
print_stack(st)
print('------')
remove_block(st,2)
print('After Removal')
print_stack(st)
print('------')

print()
print('======================================')
print()

print('Test 02')
st = Stack()
st.push(73)
st.push(85)
st.push(15)
st.push(41)
print('Stack:')
print_stack(st)
print('------')
remove_block(st,3)
print('After Removal')
print_stack(st)
print('------')

print()
print('======================================')
print()

"""Task 3: Stack Reverse"""

def conditional_reverse(stack):
    stack2=Stack()
    while stack.isEmpty()!=True:
        temp=stack.pop()
        if temp==stack.peek():
            stack2.push(stack.pop())
        else:
            stack2.push(temp)

    return stack2



print('Test 01')
st=Stack()
st.push(10)
st.push(10)
st.push(20)
st.push(20)
st.push(30)
st.push(10)
st.push(50)
print('Stack:')
print_stack(st)
print('------')
reversed_stack=conditional_reverse(st)
print('Conditional Reversed Stack:')
print_stack(reversed_stack) # This stack contains 50, 10, 30, 20, 10 in this order whereas top element should be 10
print('------')
